{"ast":null,"code":"/**\n * Estimate decoded byte length of a data:// URL *without* allocating large buffers.\n * - For base64: compute exact decoded size using length and padding;\n *               handle %XX at the character-count level (no string allocation).\n * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.\n *\n * @param {string} url\n * @returns {number}\n */\nexport default function estimateDataURLDecodedBytes(url) {\n  if (!url || typeof url !== 'string') return 0;\n  if (!url.startsWith('data:')) return 0;\n  const comma = url.indexOf(',');\n  if (comma < 0) return 0;\n  const meta = url.slice(5, comma);\n  const body = url.slice(comma + 1);\n  const isBase64 = /;base64/i.test(meta);\n  if (isBase64) {\n    let effectiveLen = body.length;\n    const len = body.length; // cache length\n\n    for (let i = 0; i < len; i++) {\n      if (body.charCodeAt(i) === 37 /* '%' */ && i + 2 < len) {\n        const a = body.charCodeAt(i + 1);\n        const b = body.charCodeAt(i + 2);\n        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);\n        if (isHex) {\n          effectiveLen -= 2;\n          i += 2;\n        }\n      }\n    }\n    let pad = 0;\n    let idx = len - 1;\n    const tailIsPct3D = j => j >= 2 && body.charCodeAt(j - 2) === 37 &&\n    // '%'\n    body.charCodeAt(j - 1) === 51 && (\n    // '3'\n    body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'\n\n    if (idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n        idx--;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n        idx -= 3;\n      }\n    }\n    if (pad === 1 && idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n      }\n    }\n    const groups = Math.floor(effectiveLen / 4);\n    const bytes = groups * 3 - (pad || 0);\n    return bytes > 0 ? bytes : 0;\n  }\n  return Buffer.byteLength(body, 'utf8');\n}","map":{"version":3,"names":["estimateDataURLDecodedBytes","url","startsWith","comma","indexOf","meta","slice","body","isBase64","test","effectiveLen","length","len","i","charCodeAt","a","b","isHex","pad","idx","tailIsPct3D","j","groups","Math","floor","bytes","Buffer","byteLength"],"sources":["D:/tourist-blog/web/node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js"],"sourcesContent":["/**\n * Estimate decoded byte length of a data:// URL *without* allocating large buffers.\n * - For base64: compute exact decoded size using length and padding;\n *               handle %XX at the character-count level (no string allocation).\n * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.\n *\n * @param {string} url\n * @returns {number}\n */\nexport default function estimateDataURLDecodedBytes(url) {\n  if (!url || typeof url !== 'string') return 0;\n  if (!url.startsWith('data:')) return 0;\n\n  const comma = url.indexOf(',');\n  if (comma < 0) return 0;\n\n  const meta = url.slice(5, comma);\n  const body = url.slice(comma + 1);\n  const isBase64 = /;base64/i.test(meta);\n\n  if (isBase64) {\n    let effectiveLen = body.length;\n    const len = body.length; // cache length\n\n    for (let i = 0; i < len; i++) {\n      if (body.charCodeAt(i) === 37 /* '%' */ && i + 2 < len) {\n        const a = body.charCodeAt(i + 1);\n        const b = body.charCodeAt(i + 2);\n        const isHex =\n          ((a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102)) &&\n          ((b >= 48 && b <= 57) || (b >= 65 && b <= 70) || (b >= 97 && b <= 102));\n\n        if (isHex) {\n          effectiveLen -= 2;\n          i += 2;\n        }\n      }\n    }\n\n    let pad = 0;\n    let idx = len - 1;\n\n    const tailIsPct3D = (j) =>\n      j >= 2 &&\n      body.charCodeAt(j - 2) === 37 && // '%'\n      body.charCodeAt(j - 1) === 51 && // '3'\n      (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'\n\n    if (idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n        idx--;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n        idx -= 3;\n      }\n    }\n\n    if (pad === 1 && idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n      }\n    }\n\n    const groups = Math.floor(effectiveLen / 4);\n    const bytes = groups * 3 - (pad || 0);\n    return bytes > 0 ? bytes : 0;\n  }\n\n  return Buffer.byteLength(body, 'utf8');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}